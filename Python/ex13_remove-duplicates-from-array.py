def cache_sum(func):
    #Декоратор для кэширования результата вычисления суммы элементов массива.
    #Это позволяет избежать повторных вычислений суммы при многократных вызовах метода.
    def wrapper(self, *args, **kwargs):
        #Если результат суммы уже вычислен и сохранён как _sum, возвращаем его.
        #Проверяем наличие атрибута _sum у экземпляра класса.
        if hasattr(self, "_sum"):
            return self._sum
        #Если нет, вычисляем сумму, сохраняем результат и возвращаем его.
        #Вызываем оригинальную функцию для вычисления суммы.
        result = func(self, *args, **kwargs)
        #Cохраняем результат вычисления в атрибут _sum для последующих вызовов.
        self._sum = result
        return result
    return wrapper


class Class:
    def __init__(self, nums):
        # Инициализация экземпляра класса.
        # Параметр nums - массив натуральных чисел, отсортированный в неубывающем порядке.
        # Создаем копию исходного массива, чтобы избежать изменения внешнего списка.
        self.nums = nums[:]
        # solution - массив, который в начале будет содержать уникальные элементы из nums
        # а оставшиеся места заполнят символом '_' (underscore).
        # Изначально пустой список для хранения результата.
        self.solution = []

    def removeDuplicates(self):
        # Метод для формирования solution.
        # Первые элементы solution должны содержать уникальные элементы из nums в их исходном порядке,
        # а оставшаяся часть массива заполнена символами '_'.

        # Если массив nums пуст, solution также будет пустым.
        if not self.nums:
            self.solution = []
            return

        # Инициализируем список уникальных элементов, начиная с первого элемента nums.
        unique = [self.nums[0]]
        # Проходим по массиву nums начиная со второго элемента.
        for num in self.nums[1:]:
            # Если текущий элемент не равен последнему найденному уникальному элементу,
            # добавляем его в список уникальных.
            if num != unique[-1]:
                unique.append(num)
        # Формируем solution: сначала идут уникальные элементы, затем заполнение '_' до длины nums.
        # Вычисляем количество символов '_', которые нужно добавить.
        fill_count = len(self.nums) - len(unique)
        # Создаем solution путем конкатенации списка уникальных элементов и списка из '_'.
        self.solution = unique + ['_'] * fill_count

    @cache_sum
    def all_sum(self):
        # Метод для вычисления суммы элементов исходного массива nums.
        # По условию временная сложность - O(N).
        total = 0
        # Проходим по всем элементам nums и суммируем их.
        for num in self.nums:
            total += num
        return total

    def __str__(self):
        # Метод печати объекта по заданному образцу.
        # Формирует строку, которая показывает исходный массив и преобразованный массив solution.
        return f"После преобразования массив {self.nums} будет выглядеть так: {self.solution}"



# Пример реализации 1:
a = Class([0,0,1,1,1,2,2,3,3,4])
a.removeDuplicates()
print(a)
print(a.all_sum())  # Ожидаемый вывод: 17

# Пример реализации 2:
b = Class([0,1,1,3,3,4,4,4,4,5])
b.removeDuplicates()
print(b)
print(b.all_sum())  # Ожидаемый вывод: 29