class Permutations:
    def __init__(self, nums): #инициализируем экземпляр
        self.nums = list(nums)  #Сохраняем как список (на случай, если передали кортеж)
        self.solution = [] #пустой список для хранения всех перестановок

    def permute(self):
        """Основной метод для генерации всех возможных перестановок.
        Использует рекурсивный алгоритм с возвратом (backtracking)."""
        self.solution = [] #очищаем список перестановок перед генерацией
        self._backtrack(0, self.nums.copy()) #запускаем рекурсивную генерацию с копией исходного списка
        return self.solution #возвращаем список всех перестановок

    def _backtrack(self, start, current):
        """Вспомогательный рекурсивный метод для генерации перестановок.
        Параметры:
            start - текущий индекс, с которого начинается генерация перестановок
            current - текущее состояние массива для генерации перестановок"""
        if start == len(current) - 1: #базовый случай рекурсии: если дошли до последнего элемента
            self.solution.append(current.copy()) #Добавляем копию текущего состояния в решение
            return

        #Рекурсивный случай: перебираем все возможные варианты для текущей позиции
        for i in range(start, len(current)):
            # Меняем местами current[start] и current[i]
            current[start], current[i] = current[i], current[start]
            # Рекурсивно генерируем перестановки для следующей позиции
            self._backtrack(start + 1, current)
            # Возвращаем обратно (backtrack) для следующих итераций
            current[start], current[i] = current[i], current[start]

    def mediana(self):
        """
        Метод для вычисления медианы первых элементов всех перестановок.
        Если список перестановок пуст, сначала генерирует перестановки.
        Возвращает:
            Медиану первых элементов всех перестановок
        """
        if not self.solution: #Если перестановки еще не сгенерированы, генерируем их
            self.permute()

        #Собираем первые элементы всех перестановок
        first_elements = [perm[0] for perm in self.solution]
        first_elements.sort() #сортируем для нахождения медианы

        n = len(first_elements)
        #Вычисляем медиану в зависимости от четности количества элементов
        if n % 2 == 1:
            return first_elements[n // 2] #Для нечетного количества - средний элемент
        else:
            return first_elements[n // 2 - 1]  #Для четного количества можно вернуть меньший из двух средних

    def __str__(self):
        return f"Для массива {self.nums} будут такие перестановки: {self.solution}"


# Пример использования
a = Permutations([1, 2, 3])
a.permute()
print(a)  # Для массива [1, 2, 3] будут такие перестановки: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]
print(a.mediana())  # 2